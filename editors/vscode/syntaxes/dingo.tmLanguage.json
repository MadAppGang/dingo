{
  "name": "Dingo",
  "scopeName": "source.dingo",
  "fileTypes": [
    "dingo"
  ],
  "patterns": [
    {
      "include": "#comments"
    },
    {
      "include": "#keywords"
    },
    {
      "include": "#result-type"
    },
    {
      "include": "#option-type"
    },
    {
      "include": "#enum-variants"
    },
    {
      "include": "#generated-variables"
    },
    {
      "include": "#types"
    },
    {
      "include": "#functions"
    },
    {
      "include": "#lambdas"
    },
    {
      "include": "#operators"
    },
    {
      "include": "#strings"
    },
    {
      "include": "#numbers"
    },
    {
      "include": "#constants"
    },
    {
      "include": "#attributes"
    }
  ],
  "repository": {
    "comments": {
      "patterns": [
        {
          "name": "comment.line.double-slash.dingo",
          "begin": "//",
          "end": "$",
          "patterns": [
            {
              "name": "meta.toc-list.banner.dingo",
              "match": "\\b(TODO|FIXME|XXX|HACK|NOTE)\\b:?"
            }
          ]
        },
        {
          "name": "comment.block.dingo",
          "begin": "/\\*",
          "end": "\\*/",
          "patterns": [
            {
              "name": "meta.toc-list.banner.dingo",
              "match": "\\b(TODO|FIXME|XXX|HACK|NOTE)\\b:?"
            }
          ]
        }
      ]
    },
    "keywords": {
      "patterns": [
        {
          "name": "keyword.control.dingo",
          "match": "\\b(if|else|for|while|loop|break|continue|return|defer|go|select|case|default)\\b"
        },
        {
          "name": "keyword.control.match.dingo",
          "match": "\\b(match)\\b",
          "comment": "Pattern matching keyword"
        },
        {
          "name": "keyword.declaration.dingo",
          "match": "\\b(func|let|const|var|type|struct|interface|enum|impl|trait)\\b"
        },
        {
          "name": "keyword.other.dingo",
          "match": "\\b(package|import|as|pub|mut)\\b"
        },
        {
          "name": "storage.modifier.dingo",
          "match": "\\b(mut|pub)\\b"
        }
      ]
    },
    "result-type": {
      "patterns": [
        {
          "name": "meta.type.result.dingo",
          "begin": "\\b(Result)\\s*(<)",
          "beginCaptures": {
            "1": {
              "name": "support.type.result.dingo"
            },
            "2": {
              "name": "punctuation.definition.typeparameters.begin.dingo"
            }
          },
          "end": "(>)",
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.typeparameters.end.dingo"
            }
          },
          "patterns": [
            {
              "include": "#types"
            },
            {
              "name": "punctuation.separator.dingo",
              "match": ","
            }
          ]
        },
        {
          "name": "support.function.constructor.result.dingo",
          "match": "\\b(Ok|Err)\\b",
          "comment": "Result constructors"
        }
      ]
    },
    "option-type": {
      "patterns": [
        {
          "name": "meta.type.option.dingo",
          "begin": "\\b(Option)\\s*(<)",
          "beginCaptures": {
            "1": {
              "name": "support.type.option.dingo"
            },
            "2": {
              "name": "punctuation.definition.typeparameters.begin.dingo"
            }
          },
          "end": "(>)",
          "endCaptures": {
            "1": {
              "name": "punctuation.definition.typeparameters.end.dingo"
            }
          },
          "patterns": [
            {
              "include": "#types"
            }
          ]
        },
        {
          "name": "support.function.constructor.option.dingo",
          "match": "\\b(Some|None)\\b",
          "comment": "Option constructors"
        }
      ]
    },
    "enum-variants": {
      "patterns": [
        {
          "name": "constant.language.enum-variant.dingo",
          "match": "\\b[A-Z][a-zA-Z0-9_]*\\b(?=\\s*(?:\\(|\\{|,|=>|\\}))",
          "comment": "Enum variant in pattern matching"
        }
      ]
    },
    "types": {
      "patterns": [
        {
          "name": "storage.type.numeric.dingo",
          "match": "\\b(int|int8|int16|int32|int64|uint|uint8|uint16|uint32|uint64|uintptr)\\b"
        },
        {
          "name": "storage.type.numeric.dingo",
          "match": "\\b(float32|float64|complex64|complex128)\\b"
        },
        {
          "name": "storage.type.string.dingo",
          "match": "\\b(string|rune|byte)\\b"
        },
        {
          "name": "storage.type.boolean.dingo",
          "match": "\\b(bool)\\b"
        },
        {
          "name": "storage.type.dingo",
          "match": "\\b(error|any)\\b"
        },
        {
          "name": "entity.name.type.dingo",
          "match": "\\b[A-Z][a-zA-Z0-9_]*\\b",
          "comment": "User-defined types (PascalCase)"
        }
      ]
    },
    "functions": {
      "patterns": [
        {
          "name": "meta.function.declaration.dingo",
          "begin": "\\b(func)\\s+([a-zA-Z_][a-zA-Z0-9_]*)\\s*(?:<[^>]*>)?\\s*\\(",
          "beginCaptures": {
            "1": {
              "name": "keyword.declaration.function.dingo"
            },
            "2": {
              "name": "entity.name.function.dingo"
            }
          },
          "end": "\\)",
          "patterns": [
            {
              "include": "#parameters"
            },
            {
              "include": "#types"
            }
          ]
        },
        {
          "name": "entity.name.function.call.dingo",
          "match": "\\b([a-z_][a-zA-Z0-9_]*)\\s*(?=\\()",
          "comment": "Function call"
        },
        {
          "name": "entity.name.function.method.dingo",
          "match": "\\.([a-z_][a-zA-Z0-9_]*)\\s*(?=\\()",
          "comment": "Method call"
        }
      ]
    },
    "lambdas": {
      "patterns": [
        {
          "name": "meta.function.lambda.dingo",
          "begin": "\\|",
          "beginCaptures": {
            "0": {
              "name": "punctuation.definition.parameters.begin.lambda.dingo"
            }
          },
          "end": "\\|",
          "endCaptures": {
            "0": {
              "name": "punctuation.definition.parameters.end.lambda.dingo"
            }
          },
          "patterns": [
            {
              "include": "#parameters"
            }
          ],
          "comment": "Rust-style lambda parameters |a, b|"
        }
      ]
    },
    "parameters": {
      "patterns": [
        {
          "name": "variable.parameter.dingo",
          "match": "\\b[a-z_][a-zA-Z0-9_]*\\b"
        }
      ]
    },
    "generated-variables": {
      "patterns": [
        {
          "name": "variable.other.generated.error.dingo",
          "match": "\\b__err\\d+\\b",
          "comment": "Generated error variable from transpiler"
        },
        {
          "name": "variable.other.generated.temp.dingo",
          "match": "\\b__tmp\\d+\\b",
          "comment": "Generated temporary variable from transpiler"
        }
      ]
    },
    "operators": {
      "patterns": [
        {
          "name": "meta.error-propagation.with-message.dingo",
          "begin": "(\\?)\\s*(?=\")",
          "beginCaptures": {
            "1": {
              "name": "keyword.operator.error-propagation.dingo"
            }
          },
          "end": "(?<=\")",
          "patterns": [
            {
              "name": "string.quoted.double.error-message.dingo",
              "begin": "\"",
              "end": "\"",
              "beginCaptures": {
                "0": {
                  "name": "punctuation.definition.string.begin.dingo"
                }
              },
              "endCaptures": {
                "0": {
                  "name": "punctuation.definition.string.end.dingo"
                }
              },
              "patterns": [
                {
                  "name": "constant.character.escape.dingo",
                  "match": "\\\\."
                }
              ]
            }
          ]
        },
        {
          "name": "keyword.operator.error-propagation.dingo",
          "match": "\\?(?!\")",
          "comment": "Error propagation operator - unwrap Result/Option or return early"
        },
        {
          "name": "keyword.operator.null-coalescing.dingo",
          "match": "\\?\\?",
          "comment": "Null coalescing operator"
        },
        {
          "name": "keyword.operator.arrow.dingo",
          "match": "=>",
          "comment": "Match arm arrow and lambda arrow"
        },
        {
          "name": "keyword.operator.assignment.dingo",
          "match": "(:=|=|\\+=|-=|\\*=|/=|%=|&=|\\|=|\\^=|<<=|>>=|&\\^=)"
        },
        {
          "name": "keyword.operator.comparison.dingo",
          "match": "(==|!=|<|>|<=|>=)"
        },
        {
          "name": "keyword.operator.logical.dingo",
          "match": "(&&|\\|\\||!)"
        },
        {
          "name": "keyword.operator.arithmetic.dingo",
          "match": "(\\+|-|\\*|/|%)"
        },
        {
          "name": "keyword.operator.bitwise.dingo",
          "match": "(&|\\||\\^|<<|>>|&\\^)"
        },
        {
          "name": "keyword.operator.channel.dingo",
          "match": "(<-)"
        },
        {
          "name": "keyword.operator.type-annotation.dingo",
          "match": ":"
        },
        {
          "name": "keyword.operator.return-type.dingo",
          "match": "->"
        }
      ]
    },
    "strings": {
      "patterns": [
        {
          "name": "string.quoted.double.dingo",
          "begin": "\"",
          "end": "\"",
          "patterns": [
            {
              "name": "constant.character.escape.dingo",
              "match": "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|[abfnrtv\\\\'\\\"])"
            },
            {
              "name": "meta.string.interpolation.dingo",
              "begin": "\\$\\{",
              "end": "\\}",
              "patterns": [
                {
                  "include": "$self"
                }
              ]
            },
            {
              "name": "invalid.illegal.unknown-escape.dingo",
              "match": "\\\\."
            }
          ]
        },
        {
          "name": "string.quoted.single.dingo",
          "begin": "'",
          "end": "'",
          "patterns": [
            {
              "name": "constant.character.escape.dingo",
              "match": "\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|U[0-9A-Fa-f]{8}|[abfnrtv\\\\'\\\"])"
            }
          ]
        },
        {
          "name": "string.quoted.raw.dingo",
          "begin": "`",
          "end": "`",
          "comment": "Raw string literal (no escaping)"
        }
      ]
    },
    "numbers": {
      "patterns": [
        {
          "name": "constant.numeric.hex.dingo",
          "match": "\\b0[xX][0-9a-fA-F_]+\\b"
        },
        {
          "name": "constant.numeric.octal.dingo",
          "match": "\\b0[oO][0-7_]+\\b"
        },
        {
          "name": "constant.numeric.binary.dingo",
          "match": "\\b0[bB][01_]+\\b"
        },
        {
          "name": "constant.numeric.float.dingo",
          "match": "\\b[0-9][0-9_]*\\.[0-9_]+([eE][+-]?[0-9_]+)?\\b"
        },
        {
          "name": "constant.numeric.integer.dingo",
          "match": "\\b[0-9][0-9_]*\\b"
        }
      ]
    },
    "constants": {
      "patterns": [
        {
          "name": "constant.language.dingo",
          "match": "\\b(true|false|nil)\\b"
        },
        {
          "name": "constant.language.iota.dingo",
          "match": "\\b(iota)\\b"
        }
      ]
    },
    "attributes": {
      "patterns": [
        {
          "name": "meta.attribute.dingo",
          "begin": "#\\[",
          "end": "\\]",
          "patterns": [
            {
              "name": "entity.name.function.attribute.dingo",
              "match": "[a-zA-Z_][a-zA-Z0-9_]*"
            }
          ],
          "comment": "Attribute syntax like"
        }
      ]
    }
  },
  "$schema": "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json"
}