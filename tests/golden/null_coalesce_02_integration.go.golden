package main

type UserOptionTag uint8

const (
	UserOptionTagSome UserOptionTag = iota
	UserOptionTagNone
)

type UserOption struct {
	tag  UserOptionTag
	some *User
}

func UserOptionSome(arg0 User) UserOption {
	return UserOption{tag: UserOptionTagSome, some: &arg0}
}
func UserOptionNone() UserOption {
	return UserOption{tag: UserOptionTagNone}
}
func (e UserOption) IsSome() bool {
	return e.tag == UserOptionTagSome
}
func (e UserOption) IsNone() bool {
	return e.tag == UserOptionTagNone
}
func (o UserOption) Map(fn func(User) User) UserOption {
	switch o.tag {
	case UserOptionTagSome:
		if o.some != nil {
			return UserOptionSome(fn(*o.some))
		}
	case UserOptionTagNone:
		return o
	}
	panic("invalid UserOption state")
}
func (o UserOption) AndThen(fn func(User) UserOption) UserOption {
	switch o.tag {
	case UserOptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case UserOptionTagNone:
		return o
	}
	panic("invalid UserOption state")
}

type AddressOptionTag uint8

const (
	AddressOptionTagSome AddressOptionTag = iota
	AddressOptionTagNone
)

type AddressOption struct {
	tag  AddressOptionTag
	some *Address
}
func AddressOptionSome(arg0 Address) AddressOption {
	return AddressOption{tag: AddressOptionTagSome, some: &arg0}
}
func AddressOptionNone() AddressOption {
	return AddressOption{tag: AddressOptionTagNone}
}
func (e AddressOption) IsSome() bool {
	return e.tag == AddressOptionTagSome
}
func (e AddressOption) IsNone() bool {
	return e.tag == AddressOptionTagNone
}
func (o AddressOption) Map(fn func(Address) Address) AddressOption {
	switch o.tag {
	case AddressOptionTagSome:
		if o.some != nil {
			return AddressOptionSome(fn(*o.some))
		}
	case AddressOptionTagNone:
		return o
	}
	panic("invalid AddressOption state")
}
func (o AddressOption) AndThen(fn func(Address) AddressOption) AddressOption {
	switch o.tag {
	case AddressOptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case AddressOptionTagNone:
		return o
	}
	panic("invalid AddressOption state")
}

type StringOptionTag uint8

const (
	StringOptionTagSome StringOptionTag = iota
	StringOptionTagNone
)

type StringOption struct {
	tag  StringOptionTag
	some *string
}
func StringOptionSome(arg0 string) StringOption {
	return StringOption{tag: StringOptionTagSome, some: &arg0}
}
func StringOptionNone() StringOption {
	return StringOption{tag: StringOptionTagNone}
}
func (e StringOption) IsSome() bool {
	return e.tag == StringOptionTagSome
}
func (e StringOption) IsNone() bool {
	return e.tag == StringOptionTagNone
}
func (o StringOption) Map(fn func(string) string) StringOption {
	switch o.tag {
	case StringOptionTagSome:
		if o.some != nil {
			return StringOptionSome(fn(*o.some))
		}
	case StringOptionTagNone:
		return o
	}
	panic("invalid StringOption state")
}
func (o StringOption) AndThen(fn func(string) StringOption) StringOption {
	switch o.tag {
	case StringOptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case StringOptionTagNone:
		return o
	}
	panic("invalid StringOption state")
}

type User struct {
	name    string
	address AddressOption
}
type Address struct {
	city StringOption
	zip  string
}
func main() {

	user := getUser(1)
	userNameOpt := func() __INFER__ {
		if user.IsNone() {
			return __INFER___None()
		}
		user := user.Unwrap()
		return user.name
	}()
	userName := func() __INFER__ {
		if userNameOpt.IsSome() {
			return __UNWRAP__(userNameOpt)
		}
		return "unknown"
	}()

	defaultCity := "San Francisco"
	addressOpt := func() __INFER__ {
		if user.IsNone() {
			return __INFER___None()
		}
		user1 := user.Unwrap()
		return user1.address
	}()
	cityOpt := __SAFE_NAV_INFER__(addressOpt, "city")
	city := func() __INFER__ {
		if cityOpt.IsSome() {
			return __UNWRAP__(cityOpt)
		}
		return defaultCity
	}()

	profile := fetchProfile()
	emailOpt := func() __INFER__ {
		if profile.IsNone() {
			return __INFER___None()
		}
		profile2 := profile.Unwrap()
		return profile2.getEmail()
	}()
	email := func() __INFER__ {
		if emailOpt.IsSome() {
			return __UNWRAP__(emailOpt)
		}
		return "no-email@example.com"
	}()

	user2 := getUser(2)
	addressOpt2 := func() __INFER__ {
		if user2.IsNone() {
			return __INFER___None()
		}
		user23 := user2.Unwrap()
		return user23.address
	}()
	zipOpt := __SAFE_NAV_INFER__(addressOpt2, "zip")
	cityOpt2 := __SAFE_NAV_INFER__(addressOpt2, "city")
	zip := func() __INFER__ {
		if zipOpt.IsSome() {
			return __UNWRAP__(zipOpt)
		}
		return "00000"
	}()
	city2 := func() __INFER__ {
		if cityOpt2.IsSome() {
			return __UNWRAP__(cityOpt2)
		}
		return "Unknown City"
	}()

	println("User:", userName, "City:", city, "Email:", email)
	println("Zip:", zip, "City2:", city2)
}
func getUser(id int) UserOption {
	if id == 1 {
		addr := AddressOptionSome(Address{
			city: StringOptionSome("New York"),
			zip:  "10001",
		})
		return UserOptionSome(User{name: "Alice", address: addr})
	}
	return UserOptionNone()
}
func fetchProfile() UserOption {
	return UserOptionNone()
}
func (u User) getEmail() StringOption {
	return StringOptionSome(u.name + "@example.com")
}
