package main

import (
	"errors"
)

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	err *error
	ok  *int
}

func ResultOk(arg0 int) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}
func (r Result) Map(fn func(int) int) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return ResultOk(fn(*r.ok))
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func (r Result) AndThen(fn func(int) Result) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return fn(*r.ok)
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func processResults(r1 Result, r2 Result) string {

	elem0, elem1 := r1, r2

	switch elem0.tag {
	case ResultTagErr:
		switch elem1.tag {
		case ResultTagErr:

			e1 := *elem0.err
			e2 := *elem1.err
			return "Both failed: " + e1.Error() + ", " + e2.Error()
		case ResultTagOk:

			e := *elem0.err
			y := *elem1.ok
			return "First failed: " + e.Error() + ", second succeeded: " + string(y)
		}
	case ResultTagOk:
		switch elem1.tag {
		case ResultTagErr:

			x := *elem0.ok
			e := *elem1.err
			return "First succeeded: " + string(x) + ", second failed: " + e.Error()
		case ResultTagOk:

			x := *elem0.ok
			y := *elem1.ok
			return "Both succeeded: " + string(x) + ", " + string(y)
		}
	}
	panic("unreachable: match is exhaustive")

}
func main() {
	r1 := ResultOk(42)
	r2 := ResultErr(errors.New("network error"))
	result := processResults(r1, r2)
	println(result)
}
