package main

import "errors"

// Test: Basic 2-element tuple matching with Result types
// Feature: Tuple pattern destructuring
// Complexity: basic

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag   ResultTag
	ok_0  *int
	err_0 *error
}

func Result_Ok(v0 int) Result {
	return Result{tag: ResultTagOk, ok_0: &v0}
}

func Result_Err(v0 error) Result {
	return Result{tag: ResultTagErr, err_0: &v0}
}

func processResults(r1 Result, r2 Result) string {
	// DINGO_MATCH_START: (r1, r2)
	__match_0_elem0, __match_0_elem1 := r1, r2
	// DINGO_TUPLE_PATTERN: (Ok, Ok) | (Ok, Err) | (Err, Ok) | (Err, Err) | ARITY: 2
	switch __match_0_elem0.tag {
	case ResultTagOk:
		x := *__match_0_elem0.ok_0
		switch __match_0_elem1.tag {
		case ResultTagOk:
			y := *__match_0_elem1.ok_0
			return "Both succeeded: " + string(x) + ", " + string(y)
		case ResultTagErr:
			e := *__match_0_elem1.err_0
			return "First succeeded: " + string(x) + ", second failed: " + e.Error()
		default:
			panic("unreachable: exhaustive match")
		}
	case ResultTagErr:
		e1 := *__match_0_elem0.err_0
		switch __match_0_elem1.tag {
		case ResultTagOk:
			y := *__match_0_elem1.ok_0
			return "First failed: " + e1.Error() + ", second succeeded: " + string(y)
		case ResultTagErr:
			e2 := *__match_0_elem1.err_0
			return "Both failed: " + e1.Error() + ", " + e2.Error()
		default:
			panic("unreachable: exhaustive match")
		}
	default:
		panic("unreachable: exhaustive match")
	}
	// DINGO_MATCH_END
}

func main() {
	r1 := Result_Ok(42)
	r2 := Result_Err(errors.New("network error"))
	result := processResults(r1, r2)
	println(result)
}
