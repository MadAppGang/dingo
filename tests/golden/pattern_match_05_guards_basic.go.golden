package main

type ResultTag uint8

const (
	ResultTag_Ok ResultTag = iota
	ResultTag_Err
)

type Result struct {
	tag   ResultTag
	ok_0  *int
	err_0 *error
}

func Result_Ok(arg0 int) Result {
	return Result{tag: ResultTag_Ok, ok_0: &arg0}
}
func Result_Err(arg0 error) Result {
	return Result{tag: ResultTag_Err, err_0: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTag_Ok
}
func (e Result) IsErr() bool {
	return e.tag == ResultTag_Err
}

// Simple guard on Result type
func classifyNumber(result Result) string {
	var __match_result_0 interface{}

	__match_0 := result
	switch __match_0.tag {
	case ResultTag_Ok:
		x := *__match_0.ok_0

		if x > 0 {
			__match_result_0 = "positive"

		} else if x < 0 {
			__match_result_0 = "negative"

		} else {
			__match_result_0 = "zero"
		}
	case ResultTag_Err:
		e := *__match_0.err_0

		__match_result_0 = "error"
	}
	panic("unreachable: match is exhaustive")
	return __match_result_0

}

// Guard with multiple conditions
func validateAge(result Result) string {
	var __match_result_1 interface{}

	__match_1 := result
	switch __match_1.tag {
	case ResultTag_Ok:
		age := *__match_1.ok_0

		if age >= 18 && age < 65 {
			__match_result_1 = "adult"

		} else if age >= 65 {
			__match_result_1 = "senior"

		} else {
			__match_result_1 = "minor"
		}
	case ResultTag_Err:

		__match_result_1 = "invalid"
	}
	panic("unreachable: match is exhaustive")
	return __match_result_1

}

// Guard with function call
func checkLength(result Result) string {
	var __match_result_2 interface{}

	__match_2 := result
	switch __match_2.tag {
	case ResultTag_Ok:
		n := *__match_2.ok_0

		if isEven(n) {
			__match_result_2 = "even"

		} else {
			__match_result_2 = "odd"
		}
	case ResultTag_Err:

		__match_result_2 = "error"
	}
	panic("unreachable: match is exhaustive")
	return __match_result_2

}
func isEven(n int) bool {
	return n%2 == 0
}
func main() {
	println(classifyNumber(Result_Ok(42)))
	println(validateAge(Result_Ok(25)))
	println(checkLength(Result_Ok(10)))
}
