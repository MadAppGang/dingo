package main

type OptionTag uint8

const (
	OptionTagSome OptionTag = iota
	OptionTagNone
)

type Option struct {
	tag  OptionTag
	some *int
}

func OptionSome(arg0 int) Option {
	return Option{tag: OptionTagSome, some: &arg0}
}
func OptionNone() Option {
	return Option{tag: OptionTagNone}
}
func (e Option) IsSome() bool {
	return e.tag == OptionTagSome
}
func (e Option) IsNone() bool {
	return e.tag == OptionTagNone
}
func (o Option) Map(fn func(int) int) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return OptionSome(fn(*o.some))
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}
func (o Option) AndThen(fn func(int) Option) Option {
	switch o.tag {
	case OptionTagSome:
		if o.some != nil {
			return fn(*o.some)
		}
	case OptionTagNone:
		return o
	}
	panic("invalid Option state")
}

type ResultTag uint8

const (
	ResultTagOk ResultTag = iota
	ResultTagErr
)

type Result struct {
	tag ResultTag
	err *error
	ok  *int
}
func ResultOk(arg0 int) Result {
	return Result{tag: ResultTagOk, ok: &arg0}
}
func ResultErr(arg0 error) Result {
	return Result{tag: ResultTagErr, err: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTagOk
}
func (e Result) IsErr() bool {
	return e.tag == ResultTagErr
}
func (r Result) Map(fn func(int) int) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return ResultOk(fn(*r.ok))
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}
func (r Result) AndThen(fn func(int) Result) Result {
	switch r.tag {
	case ResultTagOk:
		if r.ok != nil {
			return fn(*r.ok)
		}
	case ResultTagErr:
		return r
	}
	panic("invalid Result state")
}

// Using 'where' keyword (Swift-style)
func analyzeValue(opt Option) string {
	var result interface{}

	scrutinee := opt
	switch scrutinee.tag {
	case OptionTagSome:
		x := *scrutinee.some

		if x > 100 {
			result = "large"

		} else if x > 10 {
			result = "medium"

		} else if x > 0 {
			result = "small"

		} else {
			result = "non-positive"
		}
	case OptionTagNone:

		result = "none"
	}
	panic("unreachable: match is exhaustive")
	return result

}

// Simple pattern with where guards (NOT nested)
func processResult(result Result) string {
	var result2 interface{}

	scrutinee2 := result
	switch scrutinee2.tag {
	case ResultTagOk:
		val := *scrutinee2.ok

		if val > 100 {
			result2 = "large value"

		} else if val > 0 {
			result2 = "positive value"

		} else {
			result2 = "non-positive value"
		}
	case ResultTagErr:

		result2 = "error"
	}
	panic("unreachable: match is exhaustive")
	return result2

}

// Guard fallthrough demonstration
func categorize(opt Option) string {
	var result3 interface{}

	scrutinee3 := opt
	switch scrutinee3.tag {
	case OptionTagSome:
		x := *scrutinee3.some

		if x%3 == 0 && x%5 == 0 {
			result3 = "fizzbuzz"

		} else if x%3 == 0 {
			result3 = "fizz"

		} else if x%5 == 0 {
			result3 = "buzz"

		} else {
			result3 = "number"
		}
	case OptionTagNone:

		result3 = "empty"
	}
	panic("unreachable: match is exhaustive")
	return result3

}
func main() {
	println(analyzeValue(OptionSome(150)))
	println(processResult(ResultOk(42)))
	println(categorize(OptionSome(15)))
}
