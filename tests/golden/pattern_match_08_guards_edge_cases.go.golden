package main

type ValueTag uint8

const (
	ValueTag_Small ValueTag = iota
	ValueTag_Medium
	ValueTag_Large
)

type Value struct {
	tag      ValueTag
	small_0  *int
	medium_0 *int
	large_0  *int
}

func Value_Small(arg0 int) Value {
	return Value{tag: ValueTag_Small, small_0: &arg0}
}
func Value_Medium(arg0 int) Value {
	return Value{tag: ValueTag_Medium, medium_0: &arg0}
}
func Value_Large(arg0 int) Value {
	return Value{tag: ValueTag_Large, large_0: &arg0}
}
func (e Value) IsSmall() bool {
	return e.tag == ValueTag_Small
}
func (e Value) IsMedium() bool {
	return e.tag == ValueTag_Medium
}
func (e Value) IsLarge() bool {
	return e.tag == ValueTag_Large
}

// All patterns have guards (requires fallback wildcard)
func classify(val Value) string {
	var __match_result_0 interface{}

	__match_0 := val
	switch __match_0.tag {
	case ValueTag_Small:
		x := *__match_0.small_0

		if x > 10 {
			__match_result_0 = "actually medium"
		}
	case ValueTag_Medium:
		x := *__match_0.medium_0

		if x > 100 {
			__match_result_0 = "actually large"
		}
	case ValueTag_Large:
		x := *__match_0.large_0

		if x > 1000 {
			__match_result_0 = "actually huge"
		}
	default:

		__match_result_0 = "normal range"
	}
	panic("unreachable: match is exhaustive")
	return __match_result_0

}

// Wildcard pattern with guard
func filterPositive(val Value) string {
	var __match_result_1 interface{}

	__match_1 := val
	switch __match_1.tag {
	case ValueTag_Small:
		x := *__match_1.small_0

		if x > 0 {
			__match_result_1 = "positive small"
		}
	case ValueTag_Medium:
		x := *__match_1.medium_0

		if x > 0 {
			__match_result_1 = "positive medium"
		}
	case ValueTag_Large:
		x := *__match_1.large_0

		if x > 0 {
			__match_result_1 = "positive large"
		}
	default:

		__match_result_1 = "non-positive or zero"
	}
	panic("unreachable: match is exhaustive")
	return __match_result_1

}

// Many guarded arms (performance test)
func granularClassify(val Value) string {
	var __match_result_2 interface{}

	__match_2 := val
	switch __match_2.tag {
	case ValueTag_Small:
		x := *__match_2.small_0

		if x == 1 {
			__match_result_2 = "one"

		} else if x == 2 {
			__match_result_2 = "two"

		} else if x == 3 {
			__match_result_2 = "three"

		} else if x == 4 {
			__match_result_2 = "four"

		} else if x == 5 {
			__match_result_2 = "five"

		} else if x > 5 && x < 10 {
			__match_result_2 = "five to ten"

		} else {
			__match_result_2 = "small other"
		}
	case ValueTag_Medium:
		x := *__match_2.medium_0

		if x < 50 {
			__match_result_2 = "lower medium"

		} else if x >= 50 && x < 100 {
			__match_result_2 = "mid medium"

		} else {
			__match_result_2 = "upper medium"
		}
	case ValueTag_Large:

		__match_result_2 = "large"
	}
	panic("unreachable: match is exhaustive")
	return __match_result_2

}

// Guard with constant condition (optimization test)
func alwaysMatch(val Value) string {
	var __match_result_3 interface{}

	__match_3 := val
	switch __match_3.tag {
	case ValueTag_Small:

		if true {
			__match_result_3 = "small"
		}
	case ValueTag_Medium:

		if 1 > 0 {
			__match_result_3 = "medium"
		}
	case ValueTag_Large:

		__match_result_3 = "large"
	}
	panic("unreachable: match is exhaustive")
	return __match_result_3

}

// Guard with side effects (not recommended but valid)
func countMatches(val Value) string {
	var count int = 0
	var __match_result_4 interface{}

	__match_4 := val
	switch __match_4.tag {
	case ValueTag_Small:
		x := *__match_4.small_0

		if increment(&count) && x > 0 {
			__match_result_4 = "small positive"
		}
	case ValueTag_Medium:
		x := *__match_4.medium_0

		if increment(&count) && x > 0 {
			__match_result_4 = "medium positive"
		}
	case ValueTag_Large:
		x := *__match_4.large_0

		if increment(&count) && x > 0 {
			__match_result_4 = "large positive"
		}
	default:

		__match_result_4 = "other"
	}
	panic("unreachable: match is exhaustive")
	return __match_result_4

}
func increment(p *int) bool {
	*p++
	return true
}
func main() {
	println(classify(Value_Small(15)))
	println(filterPositive(Value_Medium(-5)))
	println(granularClassify(Value_Small(3)))
	println(alwaysMatch(Value_Medium(42)))
}
