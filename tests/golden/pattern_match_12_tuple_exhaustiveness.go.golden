package main

import (
	"errors"
)

type ResultTag uint8

const (
	ResultTag_Ok ResultTag = iota
	ResultTag_Err
)

type Result struct {
	tag   ResultTag
	ok_0  *int
	err_0 *error
}

func Result_Ok(arg0 int) Result {
	return Result{tag: ResultTag_Ok, ok_0: &arg0}
}
func Result_Err(arg0 error) Result {
	return Result{tag: ResultTag_Err, err_0: &arg0}
}
func (e Result) IsOk() bool {
	return e.tag == ResultTag_Ok
}
func (e Result) IsErr() bool {
	return e.tag == ResultTag_Err
}

// 6-element tuple (max limit) - demonstrates exhaustiveness with wildcards
func validateSixSteps(s1, s2, s3, s4, s5, s6 Result) string {

	__match_0_elem0, __match_0_elem1, __match_0_elem2, __match_0_elem3, __match_0_elem4, __match_0_elem5 := s1, s2, s3, s4, s5, s6

	switch __match_0_elem0.tag {
	case ResultTag_Err:
		switch __match_0_elem1.tag {
		default:
			switch __match_0_elem2.tag {
			default:
				switch __match_0_elem3.tag {
				default:
					switch __match_0_elem4.tag {
					default:
						switch __match_0_elem5.tag {
						default:

							e := *__match_0_elem0.err0
							return "Step 1 failed: " + e.Error()
						}
					}
				}
			}
		}
	case ResultTag_Ok:
		switch __match_0_elem1.tag {
		case ResultTag_Ok:
			switch __match_0_elem2.tag {
			case ResultTag_Ok:
				switch __match_0_elem3.tag {
				case ResultTag_Ok:
					switch __match_0_elem4.tag {
					case ResultTag_Ok:
						switch __match_0_elem5.tag {
						case ResultTag_Ok:

							_ := *__match_0_elem0.ok0
							_ := *__match_0_elem1.ok0
							_ := *__match_0_elem2.ok0
							_ := *__match_0_elem3.ok0
							_ := *__match_0_elem4.ok0
							_ := *__match_0_elem5.ok0
							return "All 6 steps succeeded"
						}
					}
				}
			}
		}
	default:
		switch __match_0_elem1.tag {
		case ResultTag_Err:
			switch __match_0_elem2.tag {
			default:
				switch __match_0_elem3.tag {
				default:
					switch __match_0_elem4.tag {
					default:
						switch __match_0_elem5.tag {
						default:

							e := *__match_0_elem1.err0
							return "Step 2 failed: " + e.Error()
						}
					}
				}
			}
		default:
			switch __match_0_elem2.tag {
			case ResultTag_Err:
				switch __match_0_elem3.tag {
				default:
					switch __match_0_elem4.tag {
					default:
						switch __match_0_elem5.tag {
						default:

							e := *__match_0_elem2.err0
							return "Step 3 failed: " + e.Error()
						}
					}
				}
			default:
				switch __match_0_elem3.tag {
				case ResultTag_Err:
					switch __match_0_elem4.tag {
					default:
						switch __match_0_elem5.tag {
						default:

							e := *__match_0_elem3.err0
							return "Step 4 failed: " + e.Error()
						}
					}
				default:
					switch __match_0_elem4.tag {
					case ResultTag_Err:
						switch __match_0_elem5.tag {
						default:

							e := *__match_0_elem4.err0
							return "Step 5 failed: " + e.Error()
						}
					default:
						switch __match_0_elem5.tag {
						case ResultTag_Err:

							e := *__match_0_elem5.err0
							return "Step 6 failed: " + e.Error()
						}
					}
				}
			}
		}
	}
	panic("unreachable: match is exhaustive")

}

// Example of exhaustive 4-element tuple
func processFourResults(r1, r2, r3, r4 Result) string {

	__match_1_elem0, __match_1_elem1, __match_1_elem2, __match_1_elem3 := r1, r2, r3, r4

	switch __match_1_elem0.tag {
	case ResultTag_Ok:
		switch __match_1_elem1.tag {
		case ResultTag_Ok:
			switch __match_1_elem2.tag {
			case ResultTag_Ok:
				switch __match_1_elem3.tag {
				case ResultTag_Ok:

					a := *__match_1_elem0.ok0
					b := *__match_1_elem1.ok0
					c := *__match_1_elem2.ok0
					d := *__match_1_elem3.ok0
					return "All ok: " + string(a+b+c+d)
				}
			}
		}
	default:
		switch __match_1_elem1.tag {
		default:
			switch __match_1_elem2.tag {
			default:
				switch __match_1_elem3.tag {
				default:

					return "At least one error occurred"
				}
			}
		}
	}
	panic("unreachable: match is exhaustive")

}
func main() {
	r1 := Result_Ok(1)
	r2 := Result_Ok(2)
	r3 := Result_Err(errors.New("step 3 error"))
	r4 := Result_Ok(4)
	r5 := Result_Ok(5)
	r6 := Result_Ok(6)

	result := validateSixSteps(r1, r2, r3, r4, r5, r6)
	println(result)

	result2 := processFourResults(r1, r2, r3, r4)
	println(result2)
}
