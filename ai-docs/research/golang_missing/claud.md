# What Go developers really want: The most requested features that would change how you write Go

**Go developers have been asking for the same things for years: better error handling, richer type safety, and less boilerplate**. After analyzing hundreds of proposals from the official GitHub repository (2020-2025), clear patterns emerge. Error handling improvements have topped developer surveys consistently and generated **over 200 proposals**, yet in January 2025 the Go team announced they're stopping all syntactic error handling changes indefinitely. Meanwhile, some major features have succeeded: **generics shipped in Go 1.18, structured logging (slog) in Go 1.21, and iterators in Go 1.23**. The community's highest-engagement proposal ever—sum types with **996+ thumbs up**—remains open after 8 years, exemplifying the tension between Go's minimalist philosophy and developers' desire for modern type system features.

The backstory reveals a fundamental conflict. Go was designed for simplicity and readability, with Rob Pike stating the language targets "programmers fresh out of school" who need something "easy to understand and adopt." But as Go has matured into a language for building complex systems, developers increasingly push against these constraints, requesting features standard in languages like Rust, TypeScript, and Swift. The Go team's acceptance rate tells the story: only **14% of proposals are accepted**, and language changes are extraordinarily rare compared to standard library additions.

This research identifies what developers actually struggle with daily, which proposals have captured massive community support, why most fail despite clear pain points, and what the recent acceptances of generics and iterators reveal about Go's future direction.

## Error handling remains the #1 unsolved problem after 8 years of proposals

Error handling has consistently ranked as the top complaint in Go developer surveys, yet **no proposal has achieved consensus** despite hundreds of attempts spanning 2017-2025. The core issue is simple: checking errors in Go requires repetitive boilerplate that developers find tedious. The standard pattern appears throughout Go codebases, requiring three lines for simple error returns: `x, err := someFunc()` followed by `if err != nil { return err }`. This pattern represents an estimated **1.5-1.6% of all lines in typical Go code**.

The Go team has made four major official attempts to solve this. The original 2018 check/handle draft design introduced two new keywords where `check` would automatically return on error and `handle` would define error handlers that chain together. The proposal was declined as too complicated, with stacked handlers creating readability issues. In 2019, the team simplified this to proposal **#32437**, a `try()` built-in function authored by Robert Griesemer that would enable `x := try(strconv.Atoi(a))` to return early on error. This generated **~900 comments** and overwhelming negative feedback focused on hidden control flow—`try()` could cause function returns from deep inside expressions, making control flow unclear. The team abandoned it within months, with the retrospective comment that "it might have been better to introduce a new keyword."

The most recent official attempt came in January 2025 when Ian Lance Taylor proposed **#71203**, a Rust-inspired `?` operator. The syntax allows `r := SomeFunction() ?` for simple returns or `r := SomeFunction() ? { return fmt.Errorf("something failed: %v", err) }` for error wrapping. Taylor's analysis showed this would change **1.6% of statements** in the Go standard library (8,820 statements). The proposal received mixed reception, with community members suggesting countless minor tweaks based on preferences but lacking broad consensus.

Just days after proposing the `?` operator, the Go team made a watershed announcement: **for the foreseeable future, they will stop pursuing syntactic language changes for error handling**. All open and incoming syntax-focused proposals will be closed without further investigation. The rationale reveals deeper insights: no consensus after 7+ years and hundreds of proposals, the verbosity problem "fades when errors are actually handled" rather than just returned, and the cost is too high given that changes would touch massive amounts of code. Intriguingly, at Google Cloud Next 2025, booth visitors were "adamant" Go shouldn't change error handling, suggesting the developer survey respondents may not represent all stakeholders.

Community proposals have explored equally diverse approaches. Proposal **#21161** with **840 thumbs up** suggested a Perl/Bash-inspired `||` suffix enabling `f := os.Open(filename) || &PathError{"open", filename, err}`, focusing specifically on making error wrapping easier rather than just returning unmodified errors. Other attempts include proposals for `catch` keywords, special `$` variables, Elvis operators, and dozens more variations. The common thread across all proposals is addressing the same pain point from different syntactic angles, yet the diversity of approaches itself demonstrates why consensus has been impossible.

Why have hundreds of proposals failed? The technical reasons include no community consensus, hidden control flow violating Go's explicit philosophy, the challenge of backward compatibility with 1.5% of all code needing updates, and tooling impact requiring all parsers and formatters to change. Philosophically, the status quo works—Go is successful without changes—and the Go team believes explicit error handling is clearer and better for code review despite verbosity. The process reasons include proposal fatigue, endless bikeshedding on syntax details, and no "perfect" solution given the tradeoffs. The January 2025 moratorium marks the official end of this era, shifting focus to non-syntactic improvements like better error value handling, standard library enhancements, and IDE support.

## Generics succeeded but developers immediately want more

Generics shipped in Go 1.18 (March 2022) after **10+ years of design work**, representing the most transformative language change in Go's history. The feature received **500+ thumbs up** and 400+ comments during the proposal phase, with implementation enabling type parameters for functions and types, type constraints using interfaces, and type inference. However, the conservative initial implementation deliberately excluded several features, and the community has since identified significant limitations and requested enhancements.

The most requested enhancement is **generic methods** (proposal #49085), which has garnered **836 thumbs up**—the highest support seen for any post-generics proposal. Go generics do not allow methods to have their own type parameters beyond those declared on the receiver type, preventing common patterns like functional stream processing. Developers want to write `func (b *Box[T]) Map[D any](f func(T) D) *Box[D]` to transform containers, but this is not allowed. The current workaround requires adding all potential type parameters to the struct itself, which pollutes all methods: `type Box[T any, D any] struct { Val T }`. The Go team has **declined this proposal** with documented reasoning that the interaction with interface satisfaction is unclear, implementation complexity is high, and there's potential confusion about when methods versus types are generic. This affects functional programming patterns, stream processing libraries, and builder patterns with type transformations.

**Const generics** (proposal #65555, building on earlier #44253 with **74 thumbs up**) would allow parameterizing array sizes in generic code, enabling `type Matrix[T any, N const] [N][N]T`. The original type parameters proposal explicitly noted "no parameterization on non-type values such as constants." The new proposal #65555 offers a restricted approach similar to Rust's const generics MVP, where const type parameters can only be instantiated with constant expressions or lone const type parameters, avoiding complex expressions like `N + 1`. This would enable efficient generic containers like B-Trees with parameterized node degree and matrix operations with compile-time size checking. The proposal is in **Proposal-FinalCommentPeriod** status, suggesting possible acceptance despite being open for 3+ years.

Developers also struggle with obtaining zero values for generic types in error handling contexts. When writing `func Find[T any](id string) (T, error)`, returning the zero value on error requires verbose workarounds: `var zero T` (requires declaration), `return *new(T), err` (ugly pointer indirection), or `return T{}, err` (doesn't work for all types). Multiple competing proposals exist: **#60695** suggests a builtin `zero(T)` function, **#61372** proposes an untyped `zero` identifier that adapts to required type, **#53666** wants to allow `nil` as zero for all types, and **#35966** suggests universal zero value `{}`. The Go team has concerns about overloading `nil` (already confusing for new users) and wants to avoid adding complexity for marginal benefit given that current workarounds work.

**Pointer-specific constraints** (proposal #70960, recently proposed December 2024) addresses difficulty constraining type parameters to pointer types. The problem manifests when working with structs that have pointer receivers: `func Clone[T Object](obj *T)` is rejected, and treating T as a value prevents using `new(T)` correctly. The proposal suggests syntax like `func Clone[*T Object](obj *T)` to constrain to pointer types, with use cases in cloning functions and type-safe patterns without unsafe conversions. This has a prototype implementation in PR #70959 and is under LanguageChangeReview.

Successfully implemented enhancements show the path forward. **Generic type aliases** (proposal #46477) were accepted and scheduled for Go 1.24, allowing type aliases to have their own type parameters: `type VectorAlias[T any] = Vector[T]`. **Type inference improvements** (proposal #58650) replaced Go 1.18's two separate inference passes with a unified framework using type unification, enabling inference to work in scenarios where it previously failed, such as inferring `F([]MyPtr{}, new(int))` correctly. **Range-over-function iterators** shipped in Go 1.23, enabling custom generic containers to work seamlessly with range loops through push-style iterators, solving the problem that generics made custom containers viable but lacked an iteration story.

## Sum types and enums have massive support but remain blocked by complexity

Type system enhancements represent the second-largest category of community requests after error handling. The most popular proposal in this category is **#19412 for sum types**, with **996+ thumbs up**—the highest-engagement proposal across all categories. Sum types (also called discriminated unions, tagged unions, or variant types) would allow a value to hold one of several fixed types, similar to Rust's enum system. Developers want these for type-safe result types, proper error handling with Result\<T, E\> patterns, and exhaustiveness checking at compile time.

The Go FAQ directly addresses why sum types don't exist: "We considered adding variant types to Go, but after discussion decided to leave them out because they overlap in confusing ways with interfaces. What would happen if the elements of a variant type were themselves interfaces?" This question cuts to the heart of the technical challenge—Go's existing interface system makes it unclear how variant types would discriminate between interfaces with the same methods, and the interaction model has no satisfactory solution. Russ Cox acknowledged these challenges in a 2016 Reddit AMA, noting no solution had been found despite consideration.

However, Ian Lance Taylor—a core Go team member and generics lead—authored **proposal #57644** in January 2023, representing the most promising direction. This proposal extends generics' union syntax (`T1 | T2`) to regular interfaces, enabling `type I1 interface { MyInt | MyFloat }`. A variable of this interface type could store any type in the union, with the zero value being `nil`. The key limitation is that this always has `nil` as a possible value (unlike traditional sum types) and doesn't support operators on interface values. The proposal has **248 thumbs up, 10 thumbs down** and represents a pragmatic middle ground that builds on existing generics infrastructure. Taylor's authorship signals this is a semi-official direction the Go team is seriously considering.

An alternative and more complex approach is **proposal #54685 for sigma types**, which introduces dependent types from type theory. This would enable "tagged unions where the tag is an accessible value of a type the programmer can select," supporting both value-discriminated and type-discriminated unions. The proposal is technically sophisticated, enabling use cases like JSON APIs with variant records and better unmarshaling support through reflection-accessible tags. However, the complexity is very high—dependent types are difficult to learn, require substantial compiler and runtime work, and may not be "Go-like" enough to gain acceptance.

The current workaround uses sealed interfaces with type switches. Developers create an interface with an unexported method (like `isShape()`) that prevents external types from implementing it, then define concrete types implementing that interface. The go/ast package exemplifies this pattern with sealed `Node`, `Expr`, and `Stmt` interfaces. However, this approach is verbose, requires separate type definitions for each variant, always has `nil` as a possible value, cannot enumerate variants dynamically due to reflection limitations, and lacks exhaustiveness checking that compilers could provide with native sum types.

**Enum support** has generated multiple proposals over the years (notably #19814, #28987, #28438, #36387) with high engagement, but all remain open without clear path forward. The problem with Go's current approach is that using `const` with `iota` allows invalid values—nothing prevents `SearchRequest(99)` when valid values are 0-2, requiring runtime checking and defensive programming. Proposals have suggested `enum` keywords, enums as type extensions with immutability, exhaustive switching requirements, and various other approaches. The Go team consistently declines these, viewing the iota pattern as "good enough" and preferring to avoid language complexity. Code generators like `stringer`, `go-enum`, and `enumer` fill the gap by generating String(), Parse(), and validation methods, which the community has largely accepted as the idiomatic solution.

## Type safety features clash with Go's simplicity philosophy

Beyond sum types and enums, developers have requested numerous other type safety features that have been declined due to complexity concerns. **Nillability annotations** (proposal #49202) would add `?` prefix to mark nullable types (`?*string`) with flow analysis tracking nullability through code, warning when dereferencing potentially nil values. The proposal was inspired by C# nullable reference types and authored by YairHalberstadt, a former C# compiler developer who worked on that feature.

The system would use flow analysis to determine nullability at each program point, requiring nil checks before dereferencing: `var str1 ?*string; _ = str1[0]` generates a warning, but after `if someCondition { str1 = &"hello"; _ = str1[0] }` the second line has no warning because str1 is known non-nil in that branch. The feature would integrate with error handling by making function results nullable until the error is checked: `str, err := getString(); _ = *str` warns about nil dereference, but after `if err != nil { return err }` the compiler knows str is valid.

The Go team declined this despite the clear safety benefits. The cost analysis noted this was the **second most expensive C# feature after generics**, requiring sophisticated flow analysis passes and updates to all existing code for full benefits. The proposal would add warnings to existing code, requiring a gradual adoption strategy similar to C#'s compiler flag approach. The Go team prioritizes simplicity and believes Go's typed nil is less problematic than untyped null in other languages, with explicit error handling already addressing many cases where nil issues arise.

**Immutability features** have generated multiple proposals (#27975 for const qualifier, #22876 for read-only types, #31464, #37303) all seeking compile-time immutability guarantees. Proposal #27975 suggested overloading the `const` keyword to act as an immutable type qualifier, enabling `type Config struct { const host string }` to prevent modification after initialization. Proposal #22876 proposed `ro` (read-only) keyword for references, allowing `func transmit(data ro []byte)` to prevent modification through that reference while the original owner could still modify.

The consistent objection is **const poisoning**—once you mark something const or read-only, everything that touches it must also handle the constness, creating viral propagation through APIs. Other concerns include keyword overloading confusion (const already means compile-time constant), significant type system complexity, and questionable benefit-to-cost ratio. The current workarounds involve defensive copying, documenting behavior in comments, or using the Null Object pattern. Go's philosophy favors practicality and runtime safety (via the race detector) over compile-time immutability guarantees.

The **safe navigation operator** (`?.`) proposed in #42847 would prevent nil pointer panics in nested struct access, enabling `y.b?.c` to return zero value instead of panicking when b is nil. This is familiar from C#, TypeScript, Ruby, Python, PHP, Rust, and Scala. The Go team's objection is philosophical: the operator encourages defensive programming and hides potential bugs rather than forcing explicit error handling. The proposal has mixed reception (**34 thumbs up, 11 thumbs down**), with opposition citing Go's philosophy of explicit error handling and concern that the operator makes it too easy to ignore important nil cases.

## Language features show clear boundaries of Go's minimalism

Requests for syntax sugar and language features reveal the Go team's consistent application of simplicity principles. The **ternary operator** is perhaps the most frequently requested feature that has been rejected multiple times. Developers want `result := condition ? valueIfTrue : valueIfFalse` to replace verbose if-else blocks, especially for simple conditional assignments like `max := a > b ? a : b`.

The Go FAQ directly addresses this: "The reason ?: is absent from Go is that the language's designers had seen the operation used too often to create impenetrably complex expressions. The if-else form, although longer, is unquestionably clearer. **A language needs only one conditional control flow construct**." This exemplifies Go's philosophy of prioritizing readability over brevity, with concerns that ternary operators enable nested abuse that decreases maintainability. Proposal #33171 (2019) and #67959 (2024) both attempted to revive this, with #67959 suggesting restrictions that only allow ternary when values come from variables/constants rather than function calls, but even these constrained versions haven't gained acceptance.

The current workaround requires either verbose if-else blocks, or using immediately invoked function literals: `result := func() int { if condition { return valueIfTrue }; return valueIfFalse }()`. Neither is particularly elegant, but the Go team views this as acceptable friction that encourages clearer code. Community pushback argues that readability loss is a coding problem not a language problem, and that preventing misuse shouldn't prohibit good use, but the team remains firm.

**Functional programming features** like map/filter/reduce have no formal proposals in the stdlib because Go explicitly "is not a functional language." While generic implementations are now possible with Go 1.18+, the Go team prefers explicit loops as clearer. However, the acceptance of **iterators in Go 1.23** (proposal #61405 with **364+ thumbs up**) has been a watershed moment showing the team can evolve thoughtfully. The feature allows `for i := range 10` to iterate over integers and `for v := range mySet.All` to iterate over custom containers using push-style iterator functions.

The iterator design uses function signatures like `func(yield func(E) bool)` where the yield function returns bool to indicate whether to continue iteration. This enables custom containers to provide natural iteration without collecting elements to a slice, supporting lazy evaluation and efficient tree/graph traversal. The standard library added the `iter` package with `Seq` and `Seq2` types, plus iterator support in the `slices` and `maps` packages. The success factors were clear: generics made custom containers viable but lacked an iteration story, existing solutions (collecting to slices) didn't scale, and the design fit naturally into Go's existing for-range syntax.

**Immutability and tuple proposals** show features still under consideration. Proposal #63221 suggests tuples as sugar for structs, enabling `type Point struct(int, int)` equivalent to `struct { F0 int; F1 int }`, with automatic field names. This would reduce verbosity for simple data holders and enable named tuple returns like `func divmod(a, b int) struct(quotient int, remainder int)`. The proposal remains open in discussion status with no clear decision, representing the boundary between features that might eventually be accepted versus those firmly rejected.

## Tooling improvements show where Go actually evolves

While language changes face extreme resistance, tooling improvements have seen substantial progress, revealing where the Go team prefers to invest effort. **Go modules** became the default in Go 1.16, replacing GOPATH with Minimal Version Selection (MVS) algorithm and the "import compatibility rule" that same import paths must be backward compatible. This was followed by **workspace mode in Go 1.18** (proposal #45713), which solved the "replace directive dance" for multi-module development.

Workspace mode creates a `go.work` file listing local modules, treating all as "main modules" for dependency resolution. This addressed major pain points: editing multiple modules simultaneously without replace directives, consistent dependency resolution across modules, and consistency between gopls (the language server) and command-line tools. The file should not be committed (it's for local development), and best practice adds it to `.gitignore`. Key commands include `go work init`, `go work use [module]`, and `go work sync` to sync dependencies. Community adoption has been positive, demonstrating successful tooling evolution.

**Native fuzzing** (proposal #19109 with **544 thumbs up**) was requested by Dmitry Vyukov and Konstantin Serebryany (go-fuzz authors) and implemented experimentally in Go 1.18, stabilizing in Go 1.19. The feature adds `testing.F` for fuzz tests and `go test -fuzz=FuzzTestName` command, with coverage-guided fuzzing, automatic corpus management, crash minimization, and parallel fuzzing with multiple workers. Enhancement requests continue for maximum input size limits, custom coverage instrumentation, better corpus management, and continuing fuzzing after finding bugs (proposal #56430) to avoid wasting setup time in long-running fuzz campaigns.

**Testing improvements** have focused on helper functions and framework architecture. The `t.Helper()` method (implemented in Go 1.9) marks functions as test helpers for better error reporting line numbers, representing a major improvement in test output readability. However, nested helper issues (#23249) remain where `t.Helper()` doesn't work correctly when helpers call non-test utilities. Proposals for assertion methods like `t.IsNil(err)` (#70719) and conditional error helpers (#45650) have been declined, with the Go team preferring to keep the testing package minimal and leaving rich assertions to third-party libraries like testify.

**gopls** (the Go language server) has received substantial refactoring features. Extract constant/variable/function refactorings (proposal #37170) have been implemented, code action support improved with LSP 3.16 features (#64510), and gopls version requirements modernized (proposal #65917 requiring Go 1.21+). The most requested gopls feature is **build tag handling** (proposal #29202 with **165 thumbs up**), where Linux developers want to see completions and diagnostics for Windows-tagged files and vice versa. This remains open as a high-priority issue.

**Structured logging** with the slog package (proposal #56345) shipped in Go 1.21 with **364+ thumbs up and 800+ comments during review**, addressing fragmentation in the Go logging ecosystem (logrus, zap, zerolog, etc.). The package provides structured key-value logging with levels (Debug/Info/Warn/Error), JSON/Text handlers, and crucially a common Handler interface enabling library-agnostic logging. This success story demonstrates the team's willingness to add standard library features that unify fragmented ecosystems.

## Patterns reveal Go's evolution strategy and community priorities

Analysis of proposal outcomes reveals clear patterns in what succeeds versus fails. **Acceptance criteria** require clear pain points with survey evidence and experience reports, backward compatible designs, manageable complexity additions, prototype implementations for community testing, and addressing ecosystem fragmentation. The successful features (generics, slog, iterators, workspace mode, fuzzing) all met these criteria.

**Rejection patterns** are equally consistent: proposals fail when they add language complexity without proportional benefit, provide "nice to have" features where workarounds exist, break Go's simplicity philosophy, create const poisoning or viral effects requiring widespread code changes, or are too difficult to retrofit into the existing language. The declined proposals (ternary operator, immutability, nillability annotations, generic methods, enums) all encountered one or more of these barriers.

The Go team has a **14% overall proposal acceptance rate** (170 accepted out of 1,633 total), with language changes extraordinarily rare compared to standard library additions. Russ Cox has stated "We receive many more language change proposals than we can review thoroughly," and the team explicitly errors on the side of caution for language changes. The philosophy, articulated by Rob Pike, targets "programmers fresh out of school" who need something "easy to understand and adopt" rather than researchers who can handle complex languages.

This creates fundamental tension. The **community wants** more type safety, less boilerplate, and modern language features standard in Rust, TypeScript, and Swift. The **Go team prioritizes** simplicity, backward compatibility, and proven necessity before adding features. The **success cases** (generics after 10+ years, iterators after years of discussion) show both sides can align when problems are proven over time, solutions maintain simplicity, extensive prototyping validates design, and community need is undeniable.

**Error handling remains the #1 unsolved problem** specifically because it falls into a trap: the problem is real (tops every developer survey), workarounds exist (current if err != nil pattern works), and no proposed solution achieves consensus without adding complexity the team finds unacceptable. The January 2025 moratorium represents acceptance that this particular problem may be unsolvable within Go's constraints, shifting focus to non-syntactic improvements.

The **highest-priority community requests** by engagement metrics are error handling (57+ tracked proposals, multiple with 800+ reactions), sum types (#19412 with 996+ thumbs up), generic methods (#49085 with 836 thumbs up), and structured logging (#56345 with 364+ thumbs up—now implemented). The pattern shows that high engagement doesn't guarantee acceptance—sum types and generic methods have massive support but remain blocked by technical concerns about interface interactions and implementation complexity.

## Conclusion: Go's cautious evolution serves long-term maintainability

Go's approach to language evolution reflects a deliberate choice to optimize for large teams maintaining large codebases over long periods, accepting verbose syntax as the cost of clarity and maintainability. The research reveals three key insights about Go's future direction.

First, the January 2025 error handling moratorium marks a philosophical turning point where the Go team explicitly acknowledged that some problems—even the #1 community pain point—won't be solved syntactically if no solution achieves consensus within complexity constraints. This precedent suggests other long-debated features (enums, sum types) may face similar indefinite postponement unless breakthrough designs emerge. The shift toward non-syntactic solutions (IDE features, linting, conventions) represents pragmatic acceptance that tooling evolution can address ergonomics without language changes.

Second, the post-generics enhancement requests reveal that major features spawn immediate demand for extensions. Generics succeeded because of 10+ years of careful design and community patience, but developers immediately identified limitations (no generic methods, no const generics). Ian Lance Taylor's active authorship of sum type proposals (#41716, #57644) signals these features have internal advocacy, but his error handling moratorium announcement demonstrates even core team support doesn't guarantee acceptance. The lesson is that Go evolves through extremely selective additions that must prove necessity, maintain backward compatibility, and fit within strict complexity budgets.

Third, the tooling success stories (workspace mode, slog, fuzzing, iterators) demonstrate where Go actually innovates. These features share common traits: they solve concrete workflow problems, don't require syntax changes, maintain the language's conceptual surface area, and unify fragmented ecosystems. This pattern suggests the most promising future improvements will come through standard library expansion, tooling enhancements, and compilation/runtime optimizations rather than syntax extensions. The Go team's philosophy treats language minimalism as essential to Go's identity, accepting that some developer conveniences will remain forever out of reach to preserve the simplicity that makes Go approachable for large teams and long-term maintenance.